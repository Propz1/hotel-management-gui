var Te = Object.defineProperty;
var Ye = (e, r, a) => r in e ? Te(e, r, { enumerable: !0, configurable: !0, writable: !0, value: a }) : e[r] = a;
var Y = (e, r, a) => (Ye(e, typeof r != "symbol" ? r + "" : r, a), a);
import { defineComponent as le, reactive as Ae, computed as D, watch as we, openBlock as h, createElementBlock as b, normalizeClass as F, unref as g, renderSlot as O, createElementVNode as y, createCommentVNode as oe, Fragment as A, renderList as w, toDisplayString as k, withModifiers as P, normalizeStyle as ie, createTextVNode as de } from "vue";
const H = () => U(/* @__PURE__ */ new Date()), We = (e, r, a) => {
  switch (r) {
    case "year":
      return new Date(e.getFullYear(), 0);
    case "month":
      return new Date(e.getFullYear(), e.getMonth());
    case "week":
      return J(e, a);
    default:
      return e;
  }
}, He = (e) => [...Array(7)].map((r, a) => L(e, a)), L = (e, r) => new Date(e.getFullYear(), e.getMonth(), e.getDate() + r, e.getHours(), e.getMinutes(), e.getSeconds()), J = (e, r) => L(e, (r - e.getDay() - 7) % -7), Ne = (e, r) => L(J(e, r), 7), W = (e) => new Date(e.getFullYear(), e.getMonth()), Be = (e) => Math.ceil(e.getDate() / 7), Ee = (e, r, a) => new Date(e.getFullYear() + (r == "year" ? a : 0), e.getMonth() + (r == "month" ? a : 0), e.getDate() + (r == "week" ? a * 7 : 0)), K = (e) => ("0" + String(e.getMonth() + 1)).slice(-2), X = (e) => ("0" + String(e.getDate())).slice(-2), ue = (e) => e.getFullYear() + "-" + K(e), Ue = (e) => ue(e) + "-" + X(e), Re = (e) => K(e) + "-" + X(e), Ve = (e, r, a) => {
  if (e.getHours() === 0 && e.getMinutes() === 0 && e.getSeconds() === 0)
    return "";
  if (!R()) {
    var d = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 6e4;
    return new Date(e.getTime() - d).toISOString().slice(11, 16);
  }
  return e.toLocaleTimeString(r, a);
}, ze = (e, r, a, d) => {
  const u = e.getFullYear() === r.getFullYear(), c = ge(e, r), M = !(a === "year") && !(a === "month");
  let f = [];
  return f.push(d[e.getMonth()]), M && (f.push(" "), f.push(e.getDate())), u || (f.push(M ? ", " : " "), f.push(e.getFullYear())), !c || !u ? (f.push(" – "), c || f.push(d[r.getMonth()]), M && f.push(" ")) : M && f.push(" – "), M ? (f.push(r.getDate()), f.push(", ")) : f.push(" "), f.push(r.getFullYear()), f.join("");
}, ce = (e, r) => {
  const a = Date.UTC(r.getFullYear(), r.getMonth(), r.getDate()), d = Date.UTC(e.getFullYear(), e.getMonth(), e.getDate());
  return (a - d) / 864e5;
}, je = (e, r) => !!e && !!r && ce(e, r) === 0, qe = (e, r) => !!e && !!r && e.getTime() === r.getTime(), ge = (e, r) => !!e && !!r && e.getFullYear() === r.getFullYear() && e.getMonth() === r.getMonth(), Ge = (e) => W(e) < W(H()), Qe = (e) => W(e) > W(H()), Je = (e) => U(e) > H(), Ke = (e) => U(e) < H(), Xe = (e) => e.getMonth() !== L(e, 7).getMonth(), Ze = (e) => e.getMonth() !== L(e, 1).getMonth(), me = (e) => {
  let r = [...Array(7)].map((a) => 0);
  return e.split(/\D/, 7).forEach((a, d) => r[d] = Number(a)), r[1]--, new Date(r[0], r[1], r[2], r[3], r[4], r[5], r[6]);
}, Q = (e) => typeof e == "string" ? me(e) : new Date(e), U = (e) => {
  const r = new Date(e);
  return r.setHours(0, 0, 0, 0), r;
}, xe = (e) => e.substring(0, 2), R = () => typeof Intl < "u", _e = (e, r) => {
  if (!R())
    return [...Array(12)].map((d) => "");
  const a = new Intl.DateTimeFormat(e, { month: r });
  return [...Array(12)].map((d, u) => a.format(new Date(2017, u, 1)));
}, et = (e, r, a) => {
  if (!R())
    return [...Array(7)].map((u) => "");
  const d = new Intl.DateTimeFormat(e, { weekday: r });
  return [...Array(7)].map((u, c) => d.format(new Date(2017, 0, (c + 1 + a) % 7)));
}, tt = () => typeof navigator > "u" ? "unk" : (navigator.languages && navigator.languages.length ? navigator.languages[0] : navigator.language).toLowerCase(), at = (e, r) => {
  const a = e.classes ? [...e.classes] : [];
  return r && a.push("isHovered"), {
    originalItem: e,
    startDate: Q(e.startDate),
    // For an item without an end date, the end date is the start date
    endDate: Q(e.endDate || e.startDate),
    classes: a,
    // Items without a title are untitled
    title: e.title || "Untitled",
    // An ID is *required*. Auto-generating leads to weird bugs because these are used as keys and passed in items
    id: e.id,
    // Pass the URL along
    url: e.url,
    // Use the item's title as the tooltip if the tooltip is undefined or null (but not if it is blank -- use blank to essentially disable tooltips)
    tooltip: e.tooltip ?? e.title
  };
}, n = {
  addDays: L,
  beginningOfMonth: W,
  beginningOfPeriod: We,
  beginningOfWeek: J,
  dateOnly: U,
  dayDiff: ce,
  daysOfWeek: He,
  endOfWeek: Ne,
  formattedPeriod: ze,
  formattedTime: Ve,
  fromIsoStringToLocalDate: me,
  getDefaultBrowserLocale: tt,
  getFormattedMonthNames: _e,
  getFormattedWeekdayNames: et,
  incrementPeriod: Ee,
  instanceOfMonth: Be,
  isFutureMonth: Qe,
  isInFuture: Je,
  isInPast: Ke,
  isLastDayOfMonth: Ze,
  isLastInstanceOfMonth: Xe,
  isoMonthDay: Re,
  isoYearMonth: ue,
  isoYearMonthDay: Ue,
  isPastMonth: Ge,
  isSameDate: je,
  isSameDateTime: qe,
  isSameMonth: ge,
  languageCode: xe,
  normalizeItem: at,
  paddedDay: X,
  paddedMonth: K,
  supportsIntl: R,
  today: H,
  toLocalDate: Q
};
class rt {
  constructor() {
    Y(this, "currentDragItem");
    Y(this, "dateSelectionOrigin");
    Y(this, "currentHoveredItemId", "");
    Y(this, "CalendarMath", n);
  }
}
const nt = { class: "cv-header-days" }, st = {
  key: 0,
  class: "cv-weeknumber"
}, ot = ["aria-multiselectable"], it = {
  key: 0,
  class: "cv-weeknumber"
}, lt = { class: "cv-weekdays" }, dt = ["draggable", "aria-grabbed", "aria-label", "aria-selected", "aria-dropeffect", "onClick", "onDragstart", "onDrop", "onDragover", "onDragenter", "onDragleave"], ut = { class: "cv-day-number" }, ct = ["draggable", "aria-grabbed", "title", "onDragstart", "onMouseenter", "onMouseleave", "onClick", "innerHTML"], gt = ["draggable", "aria-grabbed", "title", "onDragstart", "onMouseenter", "onMouseleave", "onClick"], Mt = /* @__PURE__ */ le({
  __name: "CalendarView",
  props: {
    showDate: { default: void 0 },
    displayPeriodUom: { default: "month" },
    displayPeriodCount: { default: 1 },
    displayWeekNumbers: { type: Boolean, default: !1 },
    locale: { default: void 0 },
    monthNameFormat: { default: "long" },
    weekdayNameFormat: { default: "short" },
    showTimes: { type: Boolean, default: !1 },
    timeFormatOptions: { default: () => ({}) },
    disablePast: { type: Boolean, default: !1 },
    disableFuture: { type: Boolean, default: !1 },
    enableDateSelection: { type: Boolean, default: !1 },
    selectionStart: { default: void 0 },
    selectionEnd: { default: void 0 },
    enableDragDrop: { type: Boolean, default: !1 },
    startingDayOfWeek: { default: 0 },
    items: { default: () => [] },
    dateClasses: { default: () => ({}) },
    itemTop: { default: "1.4em" },
    itemContentHeight: { default: "1.4em" },
    itemBorderHeight: { default: "2px" },
    periodChangedCallback: { type: Function, default: void 0 },
    currentPeriodLabel: { default: "" },
    currentPeriodLabelIcons: { default: "⇤-⇥" },
    doEmitItemMouseEvents: { type: Boolean, default: !1 },
    enableHtmlTitles: { type: Boolean, default: !0 }
  },
  emits: ["period-changed", "click-date", "click-item", "item-mouseenter", "item-mouseleave", "drag-start", "drag-over-date", "drag-enter-date", "drag-leave-date", "drop-on-date", "date-selection", "date-selection-start", "date-selection-finish"],
  setup(e, { emit: r }) {
    const a = e, d = r, u = Ae(new rt()), c = D(() => a.locale || n.getDefaultBrowserLocale()), I = D(() => a.showDate ? n.dateOnly(a.showDate) : n.today()), p = D(() => n.beginningOfPeriod(I.value, a.displayPeriodUom, a.startingDayOfWeek)), M = D(
      () => n.addDays(n.incrementPeriod(p.value, a.displayPeriodUom, a.displayPeriodCount), -1)
    ), f = D(() => {
      const t = new Date(p.value.getFullYear(), 0, 1), o = n.addDays(t, (11 - t.getDay()) % 7), i = n.beginningOfPeriod(o, "week", a.startingDayOfWeek), m = n.beginningOfWeek(p.value, a.startingDayOfWeek);
      return 1 + Math.floor(n.dayDiff(i, m) / 7);
    }), N = D(() => n.beginningOfWeek(p.value, a.startingDayOfWeek)), V = D(() => n.endOfWeek(M.value, a.startingDayOfWeek)), fe = D(() => {
      const t = Math.floor((n.dayDiff(N.value, V.value) + 1) / 7);
      return [...Array(t)].map((o, i) => n.addDays(N.value, i * 7));
    }), z = D(() => n.getFormattedMonthNames(c.value, a.monthNameFormat)), De = D(() => n.getFormattedWeekdayNames(c.value, a.weekdayNameFormat, a.startingDayOfWeek)), j = D(() => a.items ? a.items.map((t) => n.normalizeItem(t, t.id === u.currentHoveredItemId)) : []), q = D(() => n.beginningOfPeriod(n.today(), a.displayPeriodUom, a.startingDayOfWeek)), pe = D(
      () => n.addDays(n.incrementPeriod(q.value, a.displayPeriodUom, a.displayPeriodCount), -1)
    ), ve = D(() => n.formattedPeriod(p.value, M.value, a.displayPeriodUom, z.value)), he = D(() => {
      const t = q.value, o = p.value;
      return a.currentPeriodLabel ? a.currentPeriodLabel === "icons" ? a.currentPeriodLabelIcons[Math.sign(t.getTime() - o.getTime()) + 1] : a.currentPeriodLabel : n.formattedPeriod(t, pe.value, a.displayPeriodUom, z.value);
    }), be = D(
      () => ({
        // Dates for UI navigation
        previousYear: S(-12),
        previousPeriod: S(-1),
        nextPeriod: S(1),
        previousFullPeriod: S(-a.displayPeriodCount),
        nextFullPeriod: S(a.displayPeriodCount),
        nextYear: S(12),
        currentPeriod: q.value,
        currentPeriodLabel: he.value,
        // Dates for header display
        periodStart: p.value,
        periodEnd: M.value,
        // Extra information that could be useful to a custom header
        displayLocale: c.value,
        displayFirstDate: N.value,
        displayLastDate: V.value,
        monthNames: z.value,
        fixedItems: j.value,
        periodLabel: ve.value
      })
    ), ye = D(() => ({
      periodStart: p,
      periodEnd: M,
      displayFirstDate: N,
      displayLastDate: V
    }));
    we(
      () => ye,
      (t) => {
        a.periodChangedCallback && (d("period-changed"), a.periodChangedCallback(t, "watch"));
      },
      { immediate: !0, deep: !0 }
    );
    const Pe = (t, o) => {
      a.disablePast && n.isInPast(t) || a.disableFuture && n.isInFuture(t) || d("click-date", t, te(t, t), o);
    }, Z = (t, o) => d("click-item", t, o), $ = (t) => "dow" + (t + a.startingDayOfWeek) % 7, S = (t) => {
      const o = n.incrementPeriod(p.value, a.displayPeriodUom, t), i = n.incrementPeriod(o, a.displayPeriodUom, a.displayPeriodCount);
      return a.disablePast && i <= n.today() || a.disableFuture && o > n.today() ? null : o;
    }, x = (t, o) => {
      u.currentHoveredItemId = t.id, a.doEmitItemMouseEvents && d("item-mouseenter", t, o);
    }, _ = (t, o) => {
      u.currentHoveredItemId = "", a.doEmitItemMouseEvents && d("item-mouseleave", t, o);
    }, Me = (t, o) => {
      var m, s;
      if (!a.enableDateSelection)
        return !1;
      (m = o.dataTransfer) == null || m.setData("text", t.toString());
      let i = new Image();
      return i.src = "data:image/gif;base64,R0lGODlhAQABAIAAAP///wAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw==", (s = o.dataTransfer) == null || s.setDragImage(i, 10, 10), u.dateSelectionOrigin = t, d("date-selection-start", G(t), o), !0;
    }, ee = (t, o) => {
      var i;
      return a.enableDragDrop ? ((i = o.dataTransfer) == null || i.setData("text", t.id), u.currentDragItem = t, u.dateSelectionOrigin = void 0, d("drag-start", t, o), !0) : !1;
    }, G = (t) => t <= u.dateSelectionOrigin ? [t, u.dateSelectionOrigin] : [u.dateSelectionOrigin, t], ke = (t, o) => {
      a.enableDragDrop && d("drag-over-date", u.currentDragItem, t, o);
    }, Ie = (t, o) => {
      if (a.enableDateSelection && u.dateSelectionOrigin && d("date-selection", G(t), o), !a.enableDragDrop)
        return;
      d("drag-enter-date", u.currentDragItem, t, o), o.target.classList.add("draghover");
    }, Ce = (t, o) => {
      if (a.enableDateSelection && a.selectionStart || !a.enableDragDrop)
        return;
      d("drag-leave-date", u.currentDragItem, t, o), o.target.classList.remove("draghover");
    }, Oe = (t, o) => {
      if (a.enableDateSelection && u.dateSelectionOrigin) {
        d("date-selection-finish", G(t), o);
        return;
      }
      if (!a.enableDragDrop)
        return;
      d("drop-on-date", u.currentDragItem, t, o), o.target.classList.remove("draghover");
    }, Se = (t, o) => t.startDate < o.startDate ? -1 : o.startDate < t.startDate ? 1 : t.endDate > o.endDate ? -1 : o.endDate > t.endDate ? 1 : t.id < o.id ? -1 : 1, Fe = (t) => te(t, n.addDays(t, 6)), te = (t, o) => j.value.filter((i) => i.endDate >= t && n.dateOnly(i.startDate) <= o, this).sort(Se), Le = (t) => !!j.value.find((o) => o.endDate >= t && n.dateOnly(o.startDate) <= t), ae = (t) => !(!a.selectionStart || !a.selectionEnd || t < n.dateOnly(a.selectionStart) || t > n.dateOnly(a.selectionEnd)), re = (t) => {
      const o = Fe(t), i = [], m = [[], [], [], [], [], [], []];
      if (!o)
        return i;
      for (let s = 0; s < o.length; s++) {
        const l = Object.assign({}, o[s], {
          classes: [...o[s].classes],
          itemRow: 0
        }), v = l.startDate < t, T = v ? 0 : n.dayDiff(t, l.startDate), se = Math.max(1, Math.min(7 - T, n.dayDiff(n.addDays(t, T), l.endDate) + 1));
        v && l.classes.push("continued"), n.dayDiff(t, l.endDate) > 6 && l.classes.push("toBeContinued"), n.isInPast(l.endDate) && l.classes.push("past"), l.originalItem.url && l.classes.push("hasUrl");
        for (let C = 0; C < 7; C++)
          if (C === T) {
            let E = 0;
            for (; m[C][E]; )
              E++;
            l.itemRow = E, m[C][E] = !0;
          } else
            C < T + se && (m[C][l.itemRow] = !0);
        l.classes.push(`offset${T}`), l.classes.push(`span${se}`), i.push(l);
      }
      return i;
    }, $e = (t) => {
      const o = '<span class="startTime">' + n.formattedTime(t.startDate, c.value, a.timeFormatOptions) + "</span>";
      let i = "";
      return n.isSameDateTime(t.startDate, t.endDate) || (i = '<span class="endTime">' + n.formattedTime(t.endDate, c.value, a.timeFormatOptions) + "</span>"), o + i;
    }, ne = (t) => a.showTimes ? $e(t) + " " + t.title : t.title, B = (t) => {
      const o = t.itemRow, i = a.itemContentHeight, m = a.itemBorderHeight;
      return `calc(${a.itemTop} + ${o}*${i} + ${o}*${m})`;
    };
    return (t, o) => (h(), b("div", {
      "aria-label": "Calendar",
      class: F([
        "cv-wrapper",
        `locale-${g(n).languageCode(c.value)}`,
        `locale-${c.value}`,
        `y${p.value.getFullYear()}`,
        `m${g(n).paddedMonth(p.value)}`,
        `period-${t.displayPeriodUom}`,
        `periodCount-${t.displayPeriodCount}`,
        {
          past: g(n).isPastMonth(p.value),
          future: g(n).isFutureMonth(p.value),
          noIntl: !g(n).supportsIntl
        }
      ])
    }, [
      O(t.$slots, "header", { headerProps: be.value }),
      y("div", nt, [
        t.displayWeekNumbers ? (h(), b("div", st)) : oe("", !0),
        (h(!0), b(A, null, w(De.value, (i, m) => O(t.$slots, "day-header", {
          index: $(m),
          label: i
        }, () => [
          (h(), b("div", {
            key: $(m),
            class: F([$(m), "cv-header-day"])
          }, k(i), 3))
        ])), 256))
      ]),
      y("div", {
        "aria-multiselectable": t.enableDateSelection,
        class: "cv-weeks"
      }, [
        (h(!0), b(A, null, w(fe.value, (i, m) => (h(), b("div", {
          key: `${m}-week`,
          class: F(["cv-week", `week${m + 1}`, `ws${g(n).isoYearMonthDay(i)}`])
        }, [
          t.displayWeekNumbers ? (h(), b("div", it, [
            O(t.$slots, "week-number", {
              date: i,
              numberInYear: f.value + m,
              numberInPeriod: m + 1
            }, () => [
              y("span", null, k(f.value + m), 1)
            ])
          ])) : oe("", !0),
          y("div", lt, [
            (h(!0), b(A, null, w(g(n).daysOfWeek(i), (s, l) => (h(), b("div", {
              key: $(l),
              draggable: t.enableDateSelection,
              class: F([
                "cv-day",
                $(l),
                `d${g(n).isoYearMonthDay(s)}`,
                `d${g(n).isoMonthDay(s)}`,
                `d${g(n).paddedDay(s)}`,
                `instance${g(n).instanceOfMonth(s)}`,
                {
                  today: g(n).isSameDate(s, g(n).today()),
                  outsideOfMonth: !g(n).isSameMonth(s, I.value),
                  past: g(n).isInPast(s),
                  future: g(n).isInFuture(s),
                  last: g(n).isLastDayOfMonth(s),
                  lastInstance: g(n).isLastInstanceOfMonth(s),
                  hasItems: Le(s),
                  selectionStart: g(n).isSameDate(s, t.selectionStart),
                  selectionEnd: g(n).isSameDate(s, t.selectionEnd)
                },
                ...t.dateClasses && t.dateClasses[g(n).isoYearMonthDay(s)] || []
              ]),
              "aria-grabbed": t.enableDateSelection ? ae(s) : void 0,
              "aria-label": s.getDate().toString(),
              "aria-selected": ae(s),
              "aria-dropeffect": t.enableDragDrop && u.currentDragItem ? "move" : t.enableDateSelection && u.dateSelectionOrigin ? "execute" : "none",
              onClick: (v) => Pe(s, v),
              onDragstart: (v) => Me(s, v),
              onDrop: P((v) => Oe(s, v), ["prevent"]),
              onDragover: P((v) => ke(s, v), ["prevent"]),
              onDragenter: P((v) => Ie(s, v), ["prevent"]),
              onDragleave: P((v) => Ce(s, v), ["prevent"])
            }, [
              y("div", ut, k(s.getDate()), 1),
              O(t.$slots, "day-content", { day: s })
            ], 42, dt))), 128)),
            a.enableHtmlTitles ? (h(!0), b(A, { key: 0 }, w(re(i), (s) => O(t.$slots, "item", {
              value: s,
              weekStartDate: i,
              top: B(s)
            }, () => [
              (h(), b("div", {
                key: s.id,
                draggable: t.enableDragDrop,
                "aria-grabbed": t.enableDragDrop ? s == u.currentDragItem : void 0,
                class: F([s.classes, "cv-item"]),
                title: s.tooltip || s.title,
                style: ie(`top:${B(s)};${s.originalItem.style}`),
                onDragstart: (l) => ee(s, l),
                onMouseenter: (l) => x(s, l),
                onMouseleave: (l) => _(s, l),
                onClick: P((l) => Z(s, l), ["stop"]),
                innerHTML: ne(s)
              }, null, 46, ct))
            ])), 256)) : (h(!0), b(A, { key: 1 }, w(re(i), (s) => O(t.$slots, "item", {
              value: s,
              weekStartDate: i,
              top: B(s)
            }, () => [
              (h(), b("div", {
                key: s.id,
                draggable: t.enableDragDrop,
                "aria-grabbed": t.enableDragDrop ? s == u.currentDragItem : void 0,
                class: F([s.classes, "cv-item"]),
                title: s.tooltip || s.title,
                style: ie(`top:${B(s)};${s.originalItem.style}`),
                onDragstart: (l) => ee(s, l),
                onMouseenter: (l) => x(s, l),
                onMouseleave: (l) => _(s, l),
                onClick: P((l) => Z(s, l), ["stop"])
              }, k(ne(s)), 47, gt)),
              de(" div> ")
            ])), 256))
          ])
        ], 2))), 128))
      ], 8, ot)
    ], 2));
  }
}), mt = { class: "cv-header" }, ft = { class: "cv-header-nav" }, Dt = ["disabled"], pt = ["disabled", "innerHTML"], vt = ["disabled"], ht = ["disabled"], bt = { class: "periodLabel" }, kt = /* @__PURE__ */ le({
  __name: "CalendarViewHeader",
  props: {
    headerProps: {
      type: Object,
      required: !0
    },
    previousYearLabel: { type: String, default: "<<" },
    previousPeriodLabel: { type: String, default: "<" },
    nextPeriodLabel: { type: String, default: ">" },
    nextYearLabel: { type: String, default: ">>" }
  },
  emits: ["input"],
  setup(e, { emit: r }) {
    const a = r, d = (u) => a("input", u);
    return (u, c) => (h(), b("div", mt, [
      y("div", ft, [
        y("button", {
          disabled: !e.headerProps.previousYear,
          class: "previousYear",
          "aria-label": "Previous Year",
          onClick: c[0] || (c[0] = P((I) => d(e.headerProps.previousYear), ["prevent"]))
        }, k(e.previousYearLabel), 9, Dt),
        y("button", {
          disabled: !e.headerProps.previousPeriod,
          class: "previousPeriod",
          "aria-label": "Previous Period",
          onClick: c[1] || (c[1] = P((I) => d(e.headerProps.previousPeriod), ["prevent"])),
          innerHTML: e.previousPeriodLabel
        }, null, 8, pt),
        y("button", {
          class: "currentPeriod",
          "aria-label": "Current Period",
          onClick: c[2] || (c[2] = P((I) => d(e.headerProps.currentPeriod), ["prevent"]))
        }, k(e.headerProps.currentPeriodLabel), 1),
        y("button", {
          disabled: !e.headerProps.nextPeriod,
          class: "nextPeriod",
          "aria-label": "Next Period",
          onClick: c[3] || (c[3] = P((I) => d(e.headerProps.nextPeriod), ["prevent"]))
        }, k(e.nextPeriodLabel), 9, vt),
        y("button", {
          disabled: !e.headerProps.nextYear,
          class: "nextYear",
          "aria-label": "Next Year",
          onClick: c[4] || (c[4] = P((I) => d(e.headerProps.nextYear), ["prevent"]))
        }, k(e.nextYearLabel), 9, ht)
      ]),
      y("div", bt, [
        O(u.$slots, "label", {}, () => [
          de(k(e.headerProps.periodLabel), 1)
        ])
      ])
    ]));
  }
});
export {
  n as CalendarMath,
  Mt as CalendarView,
  kt as CalendarViewHeader
};
